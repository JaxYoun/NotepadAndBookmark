# 线程

* 线程是一个操作系统层面的概念，单核cpu中，如果系统开启了4个线程，这4个线程是在同一个cpu核心的若干时间分片上交替（如何交替取决于调度模型）执行的。
* 基于上面的前提，如果让4个线程挨个执行，且只有上一个执行完毕才执行下一个，由于每个线程执行耗时是一定的，整个挨个执行过程中只发生了三次线程上下文切换，与在若干时间分片上交替执行的多次上下文切换相比，岂不是效率更高，那为什么还要采取交替执行的策略呢？多线程模型存在的意义又何在呢？
* IO包括网络数据传输、磁盘读写、键盘音视频这些输入输出，系统中最主要的两种IO形式就是磁盘和网络，IO操作相比于程序在cpu中的执行是非常耗时的。DMA(DirectoryMemoryAccess)管理器是IO操作中的一个独立而关的组件，比如一个磁盘读操作是这样的
  1. cpu向DMA发出读指令，设备id、文件id以指令参数的形式传递给DMA。
  2. DMA向磁盘发出读指令，文件id以参数形式传递给磁盘。
  3. 磁盘读取对应的文件，并将之加载给内存。
  4. 读取完毕后磁盘反馈DMA、DMA再以中断的形式反馈给cpu、cpu去内存对应位置取数据。
* 由磁盘读取过程可以看到，IO操作过程中，只有很少的阶段真正需要cpu参与(IO操作其实是一个**异步**调用)，而IO往往又比较漫长，所以比较好的选择是一个线程遇到IO操作时就让出cpu权限，让其他线程来利用cpu，而不是占用着cpu去等待IO操作的结束。如果使用各线程挨个执行的方式，IO等待时间势必也算入了线程执行时间，即IO等待时cpu被闲置的占用着，利用率不高。采用分时占用的方式虽然增加了若干次的上下文切换开销，但与IO等待相比就显得微不足道了，这就是多线程方案更高效的原因。
* 我们遇到的多数系统都会遇到频繁的IO操作，所以多线程方案在绝大多数情况下都能提高cpu使用率。
* 什么IO密集型应用的线程池大小一般比cpu密集型应用的线程池更大？
  1. 对于IO密集型应用，会发生更多IO等待，需要更多的线程在IO等待过程中去占用cpu，进而提高cpu利用率。
  2. 对于计算密集型应用，IO等待较少，更多的是cpu的长时间有效占用，过多的线程容易出现明显的上下文切换开销，所以更少的线程竞争会更利于提高cpu的利用率。

#  携程

* 在做多线程开发时，开辟新线程都需要调用OS的api比较耗时，另外线程运行过程中的上下文切换、用户态和内核态的转换都带来额外的系统开销。
* 一个编程语言层面的概念，我们在编程时可以像对待线程一样操作协程，但其底层并不是线程。协程的开辟、执行都属于用户态行为，不需要调用OS线程相关的api，省去了不少开销。通常，受限于硬件资源，在系统上开辟几百上千个线程可能已是极限。而在同样的硬件上却可以轻松开辟几千万个协程。

#  异步编程模型

* 是一种编程方法实践，即父函数对子函数调用后，子函数立即返给父函数一个结果占位符，父函数拿着这个结果占位符后继续执行自己的逻辑，则函数执行完毕后就将结果通过结果占位符返给父函数同时触发预先设置的一个回调函数。对于那些比较耗时的子函数，比如子函数是IO操作，就能大大提高cpu的利用率。
* js运行时Node.js就是利用事件驱动来将程序异步化，从而使只能利用单线程的js语言能够应对高并发场景，但由于编程中大量的回调所形成的call-back-hell极大的增加了代码的复杂度，虽不影响程序执行，但对开发人员来说是一个极大的困扰。

